// если компилятор не понимает size_t, замените на int
void prefix_function (char *s, int *pi, size_t n) 
{
     pi[0]=0;          // в i-м элементе (его индекс i-1) количество совпавших символов в начале и конце для построки длины i. 
	              // p[0]=0 всегда, p[1]=1, если начинается с двух одинаковых 
     for (size_t i=1; i<n; ++i) 
     {
        int j = pi[i-1];
        while ((j > 0) && (s[i] != s[j])) // не равны
             j = pi[j-1];         // берем ранее рассчитанное значение (начиная с максимально возможных)
        if (s[i] == s[j]) // равны 
            ++j; 
        pi[i] = j;
     }
} 

Этот код добавлен по результатам обсуждения
// пример функции обработки, которая выводит индекс начала найденного образца
int f(size_t i) 
{
    printf("%d\n",i);
    return 1;
}
// str строка поиска
// obr образец, который ищем
// pi массив длин префиксов для образца (минимум столько элементов, сколько символов в образце)
// int f(size_t i) когда образец найден, вызывается эта функция. Еи передается индекс начала найденного в str образца
// функция возвращает 0, если надо прекратить поиск и 1, если надо продолжить
void prefix_find (char *str, char *obr, size_t *pi, int (*f)(size_t)) 
{
     pi[0]=0;     // в i-м элементе (его индекс i-1) количество совпавших символов в начале и конце для построки длины i. 
                  // p[0]=0 всегда, p[1]=1, если начинается с двух одинаковых 
     size_t l;    // длина образца
     // заполняем массив длин префиксов для образца
     for (l=1; obr[l]; ++l) 
     {
        size_t j = pi[l-1];
        while ((j > 0) && (obr[l] != obr[j])) // не равны
            j = pi[j-1];	         // берем ранее рассчитанное значение (начиная с максимально возможных)
        if (obr[l] == obr[j])      // равны 
            ++j; 
        pi[l] = j;
     }
     size_t j=0; // длина префикса для последнего обработанного элемента
     for (size_t i=0; str[i]; ++i) 
     {
        while ((j > 0) && (str[i] != obr[j])) // символ строки не совпал с символом в образце
            j = pi[j-1];					    // берем ранее рассчитанное значение (начиная с максимально возможных)
        if (str[i] == obr[j])				// есть совпадение 
            ++j;							// увеличиваем длину префикса на 1
        if (j==l)
            if (!f(i-l+1)) return;			// образец найден, вызовем функцию обработки
     }
} 